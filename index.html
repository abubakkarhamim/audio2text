<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Gemini Audio Transcriber</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Merriweather:wght@300;400;700;900&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <div class="container">
    <div class="settings-menu">
      <button class="settings-button" id="settingsButton">
        <svg class="icon-menu" width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
            <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
        </svg>
        <svg class="icon-close" width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
            <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
        </svg>
      </button>
      
      <div class="settings-dropdown" id="settingsDropdown">
        <div class="mb-3">
          <label for="apiKey" class="form-label">Gemini API Key</label>
          <div class="input-group">
            <input type="password" class="form-control" id="apiKey" placeholder="Enter your Gemini API key" required>
            <button class="btn btn-outline-secondary" type="button" id="saveApiKey">Save</button>
          </div>
        </div>
        <div class="mb-3">
          <label for="model" class="form-label">Model</label>
          <select class="form-select" id="model">
            <option value="gemini-2.5-flash">Gemini 2.5 Flash</option>
            <option value="gemini-2.5-pro">Gemini 2.5 Pro</option>
            <option value="gemini-1.5-flash">Gemini 1.5 Flash</option>
            <option value="gemini-1.5-pro">Gemini 1.5 Pro</option>
            <option value="gemini-pro">Gemini Pro</option>
          </select>
        </div>
        <div class="mb-3">
          <label for="prompt" class="form-label">Prompt (optional)</label>
          <input type="text" class="form-control" id="prompt" 
                 placeholder="e.g., Transcribe the audio to text. The audio is in English.">
        </div>
      </div>
    </div>

    <div class="recording-screen">
      <h3>Recording</h3>
      
      <div class="wave-animation">
        <div class="wave-dot"></div>
        <div class="wave-dot"></div>
        <div class="wave-dot"></div>
        <div class="wave-dot"></div>
      </div>

      <div class="timer" id="timer">00:00</div>

      <div class="controls">
        <button class="control-button" id="resetButton">
          <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
            <path d="M12 2v2a8 8 0 1 1-8 8H2a10 10 0 1 0 10-10z"/>
          </svg>
        </button>
        <button class="control-button" id="recordButton">
          <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
            <circle cx="12" cy="12" r="8"/>
          </svg>
        </button>
        <button class="control-button" id="finishButton">
          <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
            <path d="M9 16.2L4.8 12l-1.4 1.4L9 19 21 7l-1.4-1.4L9 16.2z"/>
          </svg>
        </button>
      </div>
    </div>

    <input type="file" id="audioFile" accept="audio/*" style="display: none;">

    <div id="transcription" class="mt-4"></div>
    <button id="copyButton" class="btn btn-secondary mt-2" style="display: none;">Copy</button>
  </div>

  <script>
    let mediaRecorder;
    let audioChunks = [];
    let transcriptionPromises = [];
    let timerInterval;
    let startTime;
    let stream;

    document.addEventListener("DOMContentLoaded", () => {
      const savedApiKey = localStorage.getItem("geminiApiKey");
      if (savedApiKey) {
        document.getElementById("apiKey").value = savedApiKey;
      }
    });

    document.getElementById("saveApiKey").addEventListener("click", () => {
      const apiKey = document.getElementById("apiKey").value;
      if (apiKey) {
        localStorage.setItem("geminiApiKey", apiKey);
        alert("API key saved locally.");
      } else {
        alert("Please enter an API key.");
      }
    });

    document.getElementById("recordButton").addEventListener("click", async () => {
      const recordButton = document.getElementById("recordButton");
      if (!mediaRecorder || mediaRecorder.state === "inactive") {
        try {
          audioChunks = [];
          transcriptionPromises = [];
          stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          console.log("Microphone stream started.");
          mediaRecorder = new MediaRecorder(stream);

          mediaRecorder.ondataavailable = event => {
            if (event.data.size > 0) {
              audioChunks.push(event.data);
              transcriptionPromises.push(transcribeChunk(event.data));
            }
          };
          
          mediaRecorder.onstop = () => {
            const blob = new Blob(audioChunks, { type: "audio/webm" });
            const file = new File([blob], "recording.webm", { type: "audio/webm" });
            const dataTransfer = new DataTransfer();
            dataTransfer.items.add(file);
            document.getElementById("audioFile").files = dataTransfer.files;
            recordButton.classList.remove("recording");
            document.querySelector('.wave-animation').classList.remove('recording');
          };

          mediaRecorder.start(10000); // Fire ondataavailable every 10 seconds
          recordButton.classList.add("recording");
          document.querySelector('.wave-animation').classList.add('recording');
          startTimer();
        } catch (err) {
          console.error("Error starting recording:", err);
          alert("Could not start recording. Please make sure you have a microphone connected and have granted permission.");
        }
      } else {
        stopRecording();
      }
    });

    document.getElementById('resetButton').addEventListener('click', () => {
      stopRecording();
      audioChunks = [];
      transcriptionPromises = [];
      document.getElementById('recordButton').classList.remove("recording");
      document.querySelector('.wave-animation').classList.remove('recording');
      document.getElementById('transcription').textContent = "";
      document.getElementById('audioFile').value = "";
      document.getElementById('copyButton').style.display = 'none';
    });

    document.getElementById('finishButton').addEventListener('click', async () => {
      stopRecording();
      // Small delay to ensure the onstop event has time to process
      setTimeout(async () => {
        const transcriptionDiv = document.getElementById("transcription");
        const copyButton = document.getElementById('copyButton');
        transcriptionDiv.textContent = "Finalizing transcription...";
        try {
          const results = await Promise.allSettled(transcriptionPromises);
          let fullTranscription = "";
          results.forEach(result => {
            if (result.status === 'fulfilled') {
              fullTranscription += result.value + " ";
            } else {
              console.error("A chunk failed to transcribe:", result.reason);
            }
          });
          transcriptionDiv.textContent = fullTranscription.trim();
          copyButton.style.display = 'block';
        } catch (err) {
          console.error("Error finalizing transcription:", err);
          transcriptionDiv.textContent = "Error: Could not finalize the transcription.";
        }
      }, 100);
    });

    document.getElementById('copyButton').addEventListener('click', () => {
      const transcriptionText = document.getElementById('transcription').textContent;
      navigator.clipboard.writeText(transcriptionText).then(() => {
        const copyButton = document.getElementById('copyButton');
        copyButton.textContent = 'Copied!';
        setTimeout(() => {
          copyButton.textContent = 'Copy';
        }, 2000);
      }).catch(err => {
        console.error('Failed to copy text: ', err);
      });
    });

    async function transcribeChunk(chunk) {
      const apiKey = document.getElementById("apiKey").value;
      const model = document.getElementById("model").value;
      const transcriptionPrompt = `Transcribe the audio to text accurately. Clean up the transcription by:
1. Removing filler words like 'um', 'uh', 'hmm', etc.
2. Removing unintentional word repetitions.
3. Maintaining intentional repetitions used for emphasis.
4. Keeping the meaning and content intact.
5. No extra information or anything, just the clean text.`;

      const reader = new FileReader();
      return new Promise((resolve, reject) => {
        reader.onload = async function() {
          const base64Data = btoa(
            new Uint8Array(reader.result)
              .reduce((data, byte) => data + String.fromCharCode(byte), '')
          );

          try {
            const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                contents: [{
                  role: "user",
                  parts: [
                    { text: transcriptionPrompt },
                    {
                      inline_data: {
                        mime_type: chunk.type,
                        data: base64Data
                      }
                    }
                  ]
                }]
              })
            });

            const data = await response.json();

            if (response.status === 429) {
              reject(new Error("Quota exceeded"));
              return;
            }

            if (data.candidates?.[0]?.content) {
              resolve(data.candidates[0].content.parts[0].text);
            } else {
              console.error("Error with API response:", data);
              reject(new Error("Could not retrieve transcription for chunk."));
            }
          } catch (err) {
            console.error("Error during transcription:", err);
            reject(err);
          }
        };
        reader.onerror = reject;
        reader.readAsArrayBuffer(chunk);
      });
    }

    function stopRecording() {
      if (mediaRecorder && mediaRecorder.state === "recording") {
        mediaRecorder.stop();
      }
      if (stream) {
        stream.getTracks().forEach(track => track.stop());
        stream = null;
        console.log("Microphone stream stopped.");
      }
      stopTimer();
    }

    function updateTimer() {
      const now = new Date().getTime();
      const elapsed = now - startTime;
      const seconds = Math.floor(elapsed / 1000);
      const minutes = Math.floor(seconds / 60);
      const displaySeconds = (seconds % 60).toString().padStart(2, '0');
      const displayMinutes = minutes.toString().padStart(2, '0');
      document.getElementById('timer').textContent = `${displayMinutes}:${displaySeconds}`;
    }

    function startTimer() {
      startTime = new Date().getTime();
      timerInterval = setInterval(updateTimer, 1000);
    }

    function stopTimer() {
      clearInterval(timerInterval);
      document.getElementById('timer').textContent = '00:00';
    }

    document.getElementById('settingsButton').addEventListener('click', (e) => {
      e.stopPropagation();
      document.getElementById('settingsDropdown').classList.toggle('show');
    });

    document.addEventListener('click', (e) => {
      if (!e.target.closest('.settings-menu')) {
        document.getElementById('settingsDropdown').classList.remove('show');
      }
    });
  </script>
</body> 
</html>
